<html>
<head>
   <meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>
   xadcps.c File Reference
</title>
<link href="$DriverApiDocsCssPath" rel="stylesheet" type="text/css">
</head>
<h3 class="PageHeader">Xilinx Processor IP Library</h3>
<hl>Software Drivers</hl>
<hr class="whs1">
<!-- Generated by Doxygen 1.4.5 -->
<div class="tabs">
  <ul>
    <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
    <li><a href="annotated.html"><span>Classes</span></a></li>
    <li id="current"><a href="files.html"><span>Files</span></a></li>
  </ul></div>
<div class="tabs">
  <ul>
    <li><a href="files.html"><span>File&nbsp;List</span></a></li>
    <li><a href="globals.html"><span>File&nbsp;Members</span></a></li>
  </ul></div>
<h1>xadcps.c File Reference</h1><hr><a name="_details"></a><h2>Detailed Description</h2>
This file contains the driver API functions that can be used to access the XADC device.<p>
Refer to the xadcps.h header file for more information about this driver.<p>
<dl compact><dt><b>Note:</b></dt><dd>None.</dd></dl>
<pre></pre><p>
<pre> MODIFICATION HISTORY:</pre><p>
<pre> Ver   Who    Date     Changes
 ----- -----  -------- -----------------------------------------------------
 1.00a ssb    12/22/11 First release based on the XPS/AXI xadc driver
 1.01a bss    02/18/13	Modified XAdcPs_SetSeqChEnables,XAdcPs_SetSeqAvgEnables
			XAdcPs_SetSeqInputMode and XAdcPs_SetSeqAcqTime APIs
			to fix CR #693371
 </pre> 
<p>
<code>#include &quot;xadcps.h&quot;</code><br>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xadcps_8c.html#2d733f758ddbec9f6adb3f7a5c92c932">XAdcPs_WriteInternalReg</a> (<a class="el" href="struct_x_adc_ps.html">XAdcPs</a> *InstancePtr, u32 RegOffset, u32 Data)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">u32&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xadcps_8c.html#5db30b0df7d870e32224c7e79b7b34c6">XAdcPs_ReadInternalReg</a> (<a class="el" href="struct_x_adc_ps.html">XAdcPs</a> *InstancePtr, u32 RegOffset)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xadcps_8c.html#ecd07d662c3b3ff363a7a833b3127f9e">XAdcPs_CfgInitialize</a> (<a class="el" href="struct_x_adc_ps.html">XAdcPs</a> *InstancePtr, <a class="el" href="struct_x_adc_ps___config.html">XAdcPs_Config</a> *ConfigPtr, u32 EffectiveAddr)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xadcps_8c.html#364d653e98319ec31d422bc6eb34d5db">XAdcPs_SetConfigRegister</a> (<a class="el" href="struct_x_adc_ps.html">XAdcPs</a> *InstancePtr, u32 Data)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">u32&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xadcps_8c.html#f818d3f49d9dfc454885686bcf0c6002">XAdcPs_GetConfigRegister</a> (<a class="el" href="struct_x_adc_ps.html">XAdcPs</a> *InstancePtr)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">u32&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xadcps_8c.html#1395661ca3eb9581400eac9fe44ac677">XAdcPs_GetMiscStatus</a> (<a class="el" href="struct_x_adc_ps.html">XAdcPs</a> *InstancePtr)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xadcps_8c.html#88cd4f42d4ae6fbd13a9a20992c47549">XAdcPs_SetMiscCtrlRegister</a> (<a class="el" href="struct_x_adc_ps.html">XAdcPs</a> *InstancePtr, u32 Data)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">u32&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xadcps_8c.html#79f9e2cba70a8b2860a77605e191b369">XAdcPs_GetMiscCtrlRegister</a> (<a class="el" href="struct_x_adc_ps.html">XAdcPs</a> *InstancePtr)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xadcps_8c.html#62c9d1e95b7bacb188900fd60364d2e9">XAdcPs_Reset</a> (<a class="el" href="struct_x_adc_ps.html">XAdcPs</a> *InstancePtr)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">u16&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xadcps_8c.html#fcd6edafb4d052282ffe8ea291974805">XAdcPs_GetAdcData</a> (<a class="el" href="struct_x_adc_ps.html">XAdcPs</a> *InstancePtr, u8 Channel)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">u16&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xadcps_8c.html#886c1913b1ac92390fb59d9e2b880f3f">XAdcPs_GetCalibCoefficient</a> (<a class="el" href="struct_x_adc_ps.html">XAdcPs</a> *InstancePtr, u8 CoeffType)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">u16&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xadcps_8c.html#e8dda0d62b866e37b8be030fb98118a8">XAdcPs_GetMinMaxMeasurement</a> (<a class="el" href="struct_x_adc_ps.html">XAdcPs</a> *InstancePtr, u8 MeasurementType)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xadcps_8c.html#9a12f9e2efed38a375540bb80d7fdd36">XAdcPs_SetAvg</a> (<a class="el" href="struct_x_adc_ps.html">XAdcPs</a> *InstancePtr, u8 Average)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">u8&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xadcps_8c.html#da2a420e4bde07c362e8df98147c87a9">XAdcPs_GetAvg</a> (<a class="el" href="struct_x_adc_ps.html">XAdcPs</a> *InstancePtr)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xadcps_8c.html#a5e8bd1e9e69cee5bfb5a5b1daa98533">XAdcPs_SetSingleChParams</a> (<a class="el" href="struct_x_adc_ps.html">XAdcPs</a> *InstancePtr, u8 Channel, int IncreaseAcqCycles, int IsEventMode, int IsDifferentialMode)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xadcps_8c.html#464cf138a9f9ffdebef7b9058bf310ee">XAdcPs_SetAlarmEnables</a> (<a class="el" href="struct_x_adc_ps.html">XAdcPs</a> *InstancePtr, u16 AlmEnableMask)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">u16&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xadcps_8c.html#175613a761ea87db87d9f699790ebaa5">XAdcPs_GetAlarmEnables</a> (<a class="el" href="struct_x_adc_ps.html">XAdcPs</a> *InstancePtr)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xadcps_8c.html#89b6af9a72a63d8492ac07eb6e707f6d">XAdcPs_SetCalibEnables</a> (<a class="el" href="struct_x_adc_ps.html">XAdcPs</a> *InstancePtr, u16 Calibration)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">u16&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xadcps_8c.html#aea5e47eb62a3f799ca0da17c50c45a3">XAdcPs_GetCalibEnables</a> (<a class="el" href="struct_x_adc_ps.html">XAdcPs</a> *InstancePtr)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xadcps_8c.html#26624a7ccd6a695882f3f199dd883a26">XAdcPs_SetSequencerMode</a> (<a class="el" href="struct_x_adc_ps.html">XAdcPs</a> *InstancePtr, u8 SequencerMode)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">u8&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xadcps_8c.html#dff9343d1535fd4dd5054e9ff9723071">XAdcPs_GetSequencerMode</a> (<a class="el" href="struct_x_adc_ps.html">XAdcPs</a> *InstancePtr)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xadcps_8c.html#84e41567de12a07d011c4c0892f73cd3">XAdcPs_SetAdcClkDivisor</a> (<a class="el" href="struct_x_adc_ps.html">XAdcPs</a> *InstancePtr, u8 Divisor)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">u8&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xadcps_8c.html#300a2c93802b32e5b67dcad65ced066a">XAdcPs_GetAdcClkDivisor</a> (<a class="el" href="struct_x_adc_ps.html">XAdcPs</a> *InstancePtr)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xadcps_8c.html#4f9f4c3d8d0b08ae1f4bef4ef443ccc6">XAdcPs_SetSeqChEnables</a> (<a class="el" href="struct_x_adc_ps.html">XAdcPs</a> *InstancePtr, u32 ChEnableMask)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">u32&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xadcps_8c.html#4dfa7cb131a2662e79d0339cda300c5f">XAdcPs_GetSeqChEnables</a> (<a class="el" href="struct_x_adc_ps.html">XAdcPs</a> *InstancePtr)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xadcps_8c.html#c475391c24bfeeb4be68e770b13cb55a">XAdcPs_SetSeqAvgEnables</a> (<a class="el" href="struct_x_adc_ps.html">XAdcPs</a> *InstancePtr, u32 AvgEnableChMask)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">u32&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xadcps_8c.html#dc282160cb9b1394d0ea2aadf5d90f72">XAdcPs_GetSeqAvgEnables</a> (<a class="el" href="struct_x_adc_ps.html">XAdcPs</a> *InstancePtr)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xadcps_8c.html#414937b31ae3cc20852834b100d91eb4">XAdcPs_SetSeqInputMode</a> (<a class="el" href="struct_x_adc_ps.html">XAdcPs</a> *InstancePtr, u32 InputModeChMask)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">u32&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xadcps_8c.html#4dfaa1fa8fafabaa9f9d8e9ef0b42a12">XAdcPs_GetSeqInputMode</a> (<a class="el" href="struct_x_adc_ps.html">XAdcPs</a> *InstancePtr)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xadcps_8c.html#d9478172811e6610b5c14677e2cab026">XAdcPs_SetSeqAcqTime</a> (<a class="el" href="struct_x_adc_ps.html">XAdcPs</a> *InstancePtr, u32 AcqCyclesChMask)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">u32&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xadcps_8c.html#94ad3347301c4ccd8a18ff349bedf861">XAdcPs_GetSeqAcqTime</a> (<a class="el" href="struct_x_adc_ps.html">XAdcPs</a> *InstancePtr)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xadcps_8c.html#8446d59497c00607c474742f6872f31e">XAdcPs_SetAlarmThreshold</a> (<a class="el" href="struct_x_adc_ps.html">XAdcPs</a> *InstancePtr, u8 AlarmThrReg, u16 Value)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">u16&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xadcps_8c.html#c79021b54c5c3c21aef08f553a6dc6a4">XAdcPs_GetAlarmThreshold</a> (<a class="el" href="struct_x_adc_ps.html">XAdcPs</a> *InstancePtr, u8 AlarmThrReg)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xadcps_8c.html#df7eeb47d1d8686cff771cdc57e59eb4">XAdcPs_EnableUserOverTemp</a> (<a class="el" href="struct_x_adc_ps.html">XAdcPs</a> *InstancePtr)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xadcps_8c.html#1221b43839eb5fafb64cffdd6b01f255">XAdcPs_DisableUserOverTemp</a> (<a class="el" href="struct_x_adc_ps.html">XAdcPs</a> *InstancePtr)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xadcps_8c.html#c7d91697f463582f5f48d5aff623b778">XAdcPs_SetSequencerEvent</a> (<a class="el" href="struct_x_adc_ps.html">XAdcPs</a> *InstancePtr, int IsEventMode)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xadcps_8c.html#c96fca413eb7d00570a06f71550bfe4c">XAdcPs_GetSamplingMode</a> (<a class="el" href="struct_x_adc_ps.html">XAdcPs</a> *InstancePtr)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xadcps_8c.html#1d913d7cb0af6268eb81e2adfbe0f605">XAdcPs_SetMuxMode</a> (<a class="el" href="struct_x_adc_ps.html">XAdcPs</a> *InstancePtr, int MuxMode, u8 Channel)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xadcps_8c.html#81888ec31e0f6069c9186c3f29c19712">XAdcPs_SetPowerdownMode</a> (<a class="el" href="struct_x_adc_ps.html">XAdcPs</a> *InstancePtr, u32 Mode)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">u32&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xadcps_8c.html#14e6d7094dbbef27dadd2f4eafe9e1d1">XAdcPs_GetPowerdownMode</a> (<a class="el" href="struct_x_adc_ps.html">XAdcPs</a> *InstancePtr)</td></tr>

</table>
<hr><h2>Function Documentation</h2>
<a class="anchor" name="ecd07d662c3b3ff363a7a833b3127f9e"></a><!-- doxytag: member="xadcps.c::XAdcPs_CfgInitialize" ref="ecd07d662c3b3ff363a7a833b3127f9e" args="(XAdcPs *InstancePtr, XAdcPs_Config *ConfigPtr, u32 EffectiveAddr)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">int XAdcPs_CfgInitialize           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="struct_x_adc_ps.html">XAdcPs</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap><a class="el" href="struct_x_adc_ps___config.html">XAdcPs_Config</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>ConfigPtr</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>u32&nbsp;</td>
          <td class="mdname" nowrap> <em>EffectiveAddr</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
This function initializes a specific <a class="el" href="struct_x_adc_ps.html">XAdcPs</a> device/instance. This function must be called prior to using the XADC device.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the <a class="el" href="struct_x_adc_ps.html">XAdcPs</a> instance. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>ConfigPtr</em>&nbsp;</td><td>points to the <a class="el" href="struct_x_adc_ps.html">XAdcPs</a> device configuration structure. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>EffectiveAddr</em>&nbsp;</td><td>is the device base address in the virtual memory address space. If the address translation is not used then the physical address is passed. Unexpected errors may occur if the address mapping is changed after this function is invoked.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd><ul>
<li>XST_SUCCESS if successful.</li></ul>
</dd></dl>
<dl compact><dt><b>Note:</b></dt><dd>The user needs to first call the <a class="el" href="xadcps__sinit_8c.html#4739f71bd0b4bdb8561e2fa97dfbb416">XAdcPs_LookupConfig()</a> API which returns the Configuration structure pointer which is passed as a parameter to the <a class="el" href="xadcps_8c.html#ecd07d662c3b3ff363a7a833b3127f9e">XAdcPs_CfgInitialize()</a> API. </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="1221b43839eb5fafb64cffdd6b01f255"></a><!-- doxytag: member="xadcps.c::XAdcPs_DisableUserOverTemp" ref="1221b43839eb5fafb64cffdd6b01f255" args="(XAdcPs *InstancePtr)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">void XAdcPs_DisableUserOverTemp           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="struct_x_adc_ps.html">XAdcPs</a> *&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>InstancePtr</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
This function disables programming of the powerdown temperature for the OverTemp signal in the OT Powerdown register.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the <a class="el" href="struct_x_adc_ps.html">XAdcPs</a> instance.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>None.</dd></dl>
<dl compact><dt><b>Note:</b></dt><dd>None. </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="df7eeb47d1d8686cff771cdc57e59eb4"></a><!-- doxytag: member="xadcps.c::XAdcPs_EnableUserOverTemp" ref="df7eeb47d1d8686cff771cdc57e59eb4" args="(XAdcPs *InstancePtr)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">void XAdcPs_EnableUserOverTemp           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="struct_x_adc_ps.html">XAdcPs</a> *&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>InstancePtr</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
This function enables programming of the powerdown temperature for the OverTemp signal in the OT Powerdown register.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the <a class="el" href="struct_x_adc_ps.html">XAdcPs</a> instance.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>None.</dd></dl>
<dl compact><dt><b>Note:</b></dt><dd>None. </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="300a2c93802b32e5b67dcad65ced066a"></a><!-- doxytag: member="xadcps.c::XAdcPs_GetAdcClkDivisor" ref="300a2c93802b32e5b67dcad65ced066a" args="(XAdcPs *InstancePtr)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">u8 XAdcPs_GetAdcClkDivisor           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="struct_x_adc_ps.html">XAdcPs</a> *&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>InstancePtr</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
The function gets the ADCCLK divisor from the Configuration Register 2.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the <a class="el" href="struct_x_adc_ps.html">XAdcPs</a> instance.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>The divisor read from the Configuration Register 2.</dd></dl>
<dl compact><dt><b>Note:</b></dt><dd>The ADCCLK is an internal clock used by the ADC and is synchronized to the DCLK clock. The ADCCLK is equal to DCLK divided by the user selection in the Configuration Register 2. </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="fcd6edafb4d052282ffe8ea291974805"></a><!-- doxytag: member="xadcps.c::XAdcPs_GetAdcData" ref="fcd6edafb4d052282ffe8ea291974805" args="(XAdcPs *InstancePtr, u8 Channel)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">u16 XAdcPs_GetAdcData           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="struct_x_adc_ps.html">XAdcPs</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>u8&nbsp;</td>
          <td class="mdname" nowrap> <em>Channel</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Get the ADC converted data for the specified channel.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the <a class="el" href="struct_x_adc_ps.html">XAdcPs</a> instance. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>Channel</em>&nbsp;</td><td>is the channel number. Use the XADCPS_CH_* defined in the file xadcps.h. The valid channels are<ul>
<li>0 to 6</li><li>13 to 31</li></ul>
</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>A 16-bit value representing the ADC converted data for the specified channel. The XADC Monitor/ADC device guarantees a 10 bit resolution for the ADC converted data and data is the 10 MSB bits of the 16 data read from the device.</dd></dl>
<dl compact><dt><b>Note:</b></dt><dd>The channels 7,8,9 are used for calibration of the device and hence there is no associated data with this channel. </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="175613a761ea87db87d9f699790ebaa5"></a><!-- doxytag: member="xadcps.c::XAdcPs_GetAlarmEnables" ref="175613a761ea87db87d9f699790ebaa5" args="(XAdcPs *InstancePtr)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">u16 XAdcPs_GetAlarmEnables           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="struct_x_adc_ps.html">XAdcPs</a> *&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>InstancePtr</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
This function gets the status of the alarm output enables in the Configuration Register 1.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the <a class="el" href="struct_x_adc_ps.html">XAdcPs</a> instance.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>This is the bit-mask of the enabled alarm outputs in the Configuration Register 1. Use the masks XADCPS_CFR1_ALM*_* and XADCPS_CFR1_OT_MASK defined in <a class="el" href="xadcps__hw_8h.html">xadcps_hw.h</a> to interpret the returned value. Bit positions of 1 indicate that the alarm output is enabled. Bit positions of 0 indicate that the alarm output is disabled.</dd></dl>
<dl compact><dt><b>Note:</b></dt><dd>The implementation of the alarm enables in the Configuration register 1 is such that alarms for the bit positions of 1 will be disabled and alarms for bit positions of 0 will be enabled. The enabled alarm outputs returned by this function is the negated value of the the data read from the Configuration Register 1. </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="c79021b54c5c3c21aef08f553a6dc6a4"></a><!-- doxytag: member="xadcps.c::XAdcPs_GetAlarmThreshold" ref="c79021b54c5c3c21aef08f553a6dc6a4" args="(XAdcPs *InstancePtr, u8 AlarmThrReg)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">u16 XAdcPs_GetAlarmThreshold           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="struct_x_adc_ps.html">XAdcPs</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>u8&nbsp;</td>
          <td class="mdname" nowrap> <em>AlarmThrReg</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
This function returns the contents of the specified Alarm Threshold Register.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the <a class="el" href="struct_x_adc_ps.html">XAdcPs</a> instance. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>AlarmThrReg</em>&nbsp;</td><td>is the index of an Alarm Threshold Register to be read. Use XADCPS_ATR_* constants defined in <a class="el" href="xadcps__hw_8h.html">xadcps_hw.h</a> to specify the index.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>A 16-bit value representing the contents of the selected Alarm Threshold Register.</dd></dl>
<dl compact><dt><b>Note:</b></dt><dd>None. </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="da2a420e4bde07c362e8df98147c87a9"></a><!-- doxytag: member="xadcps.c::XAdcPs_GetAvg" ref="da2a420e4bde07c362e8df98147c87a9" args="(XAdcPs *InstancePtr)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">u8 XAdcPs_GetAvg           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="struct_x_adc_ps.html">XAdcPs</a> *&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>InstancePtr</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
This function returns the number of samples of averaging configured for all the channels in the Configuration Register 0.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the <a class="el" href="struct_x_adc_ps.html">XAdcPs</a> instance.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>The averaging read from the Configuration Register 0 is returned. Use the XADCPS_AVG_* bit definitions defined in xadcps.h file to interpret the returned value :<ul>
<li>XADCPS_AVG_0_SAMPLES means no averaging</li><li>XADCPS_AVG_16_SAMPLES means 16 samples of averaging</li><li>XADCPS_AVG_64_SAMPLES means 64 samples of averaging</li><li>XADCPS_AVG_256_SAMPLES means 256 samples of averaging</li></ul>
</dd></dl>
<dl compact><dt><b>Note:</b></dt><dd>None. </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="886c1913b1ac92390fb59d9e2b880f3f"></a><!-- doxytag: member="xadcps.c::XAdcPs_GetCalibCoefficient" ref="886c1913b1ac92390fb59d9e2b880f3f" args="(XAdcPs *InstancePtr, u8 CoeffType)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">u16 XAdcPs_GetCalibCoefficient           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="struct_x_adc_ps.html">XAdcPs</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>u8&nbsp;</td>
          <td class="mdname" nowrap> <em>CoeffType</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
This function gets the calibration coefficient data for the specified parameter.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the <a class="el" href="struct_x_adc_ps.html">XAdcPs</a> instance. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>CoeffType</em>&nbsp;</td><td>specifies the calibration coefficient to be read. Use XADCPS_CALIB_* constants defined in xadcps.h to specify the calibration coefficient to be read.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>A 16-bit value representing the calibration coefficient. The XADC device guarantees a 10 bit resolution for the ADC converted data and data is the 10 MSB bits of the 16 data read from the device.</dd></dl>
<dl compact><dt><b>Note:</b></dt><dd>None. </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="aea5e47eb62a3f799ca0da17c50c45a3"></a><!-- doxytag: member="xadcps.c::XAdcPs_GetCalibEnables" ref="aea5e47eb62a3f799ca0da17c50c45a3" args="(XAdcPs *InstancePtr)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">u16 XAdcPs_GetCalibEnables           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="struct_x_adc_ps.html">XAdcPs</a> *&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>InstancePtr</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
This function reads the value of the calibration enables from the Configuration Register 1.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the <a class="el" href="struct_x_adc_ps.html">XAdcPs</a> instance.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>The value of the calibration enables in the Configuration Register 1 :<ul>
<li>XADCPS_CFR1_CAL_ADC_OFFSET_MASK : ADC offset correction</li><li>XADCPS_CFR1_CAL_ADC_GAIN_OFFSET_MASK : ADC gain and offset correction</li><li>XADCPS_CFR1_CAL_PS_OFFSET_MASK : Power Supply sensor offset correction</li><li>XADCPS_CFR1_CAL_PS_GAIN_OFFSET_MASK : Power Supply sensor gain and offset correction</li><li>XADCPS_CFR1_CAL_DISABLE_MASK : No Calibration</li></ul>
</dd></dl>
<dl compact><dt><b>Note:</b></dt><dd>None. </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="f818d3f49d9dfc454885686bcf0c6002"></a><!-- doxytag: member="xadcps.c::XAdcPs_GetConfigRegister" ref="f818d3f49d9dfc454885686bcf0c6002" args="(XAdcPs *InstancePtr)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">u32 XAdcPs_GetConfigRegister           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="struct_x_adc_ps.html">XAdcPs</a> *&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>InstancePtr</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
The functions reads the contents of the Config Register.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the <a class="el" href="struct_x_adc_ps.html">XAdcPs</a> instance.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>A 32-bit value representing the contents of the Config Register. Use the XADCPS_SR_*_MASK constants defined in <a class="el" href="xadcps__hw_8h.html">xadcps_hw.h</a> to interpret the returned value.</dd></dl>
<dl compact><dt><b>Note:</b></dt><dd>None. </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="e8dda0d62b866e37b8be030fb98118a8"></a><!-- doxytag: member="xadcps.c::XAdcPs_GetMinMaxMeasurement" ref="e8dda0d62b866e37b8be030fb98118a8" args="(XAdcPs *InstancePtr, u8 MeasurementType)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">u16 XAdcPs_GetMinMaxMeasurement           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="struct_x_adc_ps.html">XAdcPs</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>u8&nbsp;</td>
          <td class="mdname" nowrap> <em>MeasurementType</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
This function reads the Minimum/Maximum measurement for one of the specified parameters. Use XADCPS_MAX_* and XADCPS_MIN_* constants defined in xadcps.h to specify the parameters (Temperature, VccInt, VccAux, VBram, VccPInt, VccPAux and VccPDro).<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the <a class="el" href="struct_x_adc_ps.html">XAdcPs</a> instance. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>MeasurementType</em>&nbsp;</td><td>specifies the parameter for which the Minimum/Maximum measurement has to be read. Use XADCPS_MAX_* and XADCPS_MIN_* constants defined in xadcps.h to specify the data to be read.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>A 16-bit value representing the maximum/minimum measurement for specified parameter. The XADC device guarantees a 10 bit resolution for the ADC converted data and data is the 10 MSB bits of the 16 data read from the device.</dd></dl>
<dl compact><dt><b>Note:</b></dt><dd>None. </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="79f9e2cba70a8b2860a77605e191b369"></a><!-- doxytag: member="xadcps.c::XAdcPs_GetMiscCtrlRegister" ref="79f9e2cba70a8b2860a77605e191b369" args="(XAdcPs *InstancePtr)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">u32 XAdcPs_GetMiscCtrlRegister           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="struct_x_adc_ps.html">XAdcPs</a> *&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>InstancePtr</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
The functions reads the contents of the Miscellaneous control register.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the <a class="el" href="struct_x_adc_ps.html">XAdcPs</a> instance.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>A 32-bit value representing the contents of the Config Register. Use the XADCPS_SR_*_MASK constants defined in <a class="el" href="xadcps__hw_8h.html">xadcps_hw.h</a> to interpret the returned value.</dd></dl>
<dl compact><dt><b>Note:</b></dt><dd>None. </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="1395661ca3eb9581400eac9fe44ac677"></a><!-- doxytag: member="xadcps.c::XAdcPs_GetMiscStatus" ref="1395661ca3eb9581400eac9fe44ac677" args="(XAdcPs *InstancePtr)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">u32 XAdcPs_GetMiscStatus           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="struct_x_adc_ps.html">XAdcPs</a> *&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>InstancePtr</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
The functions reads the contents of the Miscellaneous Status Register.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the <a class="el" href="struct_x_adc_ps.html">XAdcPs</a> instance.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>A 32-bit value representing the contents of the Miscellaneous Status Register. Use the XADCPS_MSTS_*_MASK constants defined in <a class="el" href="xadcps__hw_8h.html">xadcps_hw.h</a> to interpret the returned value.</dd></dl>
<dl compact><dt><b>Note:</b></dt><dd>None. </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="14e6d7094dbbef27dadd2f4eafe9e1d1"></a><!-- doxytag: member="xadcps.c::XAdcPs_GetPowerdownMode" ref="14e6d7094dbbef27dadd2f4eafe9e1d1" args="(XAdcPs *InstancePtr)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">u32 XAdcPs_GetPowerdownMode           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="struct_x_adc_ps.html">XAdcPs</a> *&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>InstancePtr</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
This function gets the Power Down mode.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the <a class="el" href="struct_x_adc_ps.html">XAdcPs</a> instance.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>Mode specifies the Power Down Mode<ul>
<li>XADCPS_PD_MODE_NONE specifies NO Power Down (Both ADC A and ADC B are enabled)</li><li>XADCPS_PD_MODE_ADCB specfies the Power Down of ADC B</li><li>XADCPS_PD_MODE_XADC specifies the Power Down of both ADC A and ADC B.</li></ul>
</dd></dl>
<dl compact><dt><b>Note:</b></dt><dd>None. </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="c96fca413eb7d00570a06f71550bfe4c"></a><!-- doxytag: member="xadcps.c::XAdcPs_GetSamplingMode" ref="c96fca413eb7d00570a06f71550bfe4c" args="(XAdcPs *InstancePtr)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">int XAdcPs_GetSamplingMode           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="struct_x_adc_ps.html">XAdcPs</a> *&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>InstancePtr</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
This function returns the sampling mode.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the <a class="el" href="struct_x_adc_ps.html">XAdcPs</a> instance.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>The sampling mode<ul>
<li>0 specifies continuous sampling</li><li>1 specifies event driven sampling mode</li></ul>
</dd></dl>
<dl compact><dt><b>Note:</b></dt><dd>None. </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="94ad3347301c4ccd8a18ff349bedf861"></a><!-- doxytag: member="xadcps.c::XAdcPs_GetSeqAcqTime" ref="94ad3347301c4ccd8a18ff349bedf861" args="(XAdcPs *InstancePtr)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">u32 XAdcPs_GetSeqAcqTime           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="struct_x_adc_ps.html">XAdcPs</a> *&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>InstancePtr</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
This function gets the status of acquisition from the ADC Channel Acquisition Time Sequencer Registers.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the <a class="el" href="struct_x_adc_ps.html">XAdcPs</a> instance.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>The acquisition time for all the channels. Use XADCPS_SEQ_CH__* defined in <a class="el" href="xadcps__hw_8h.html">xadcps_hw.h</a> to interpret the Channel numbers. Bit masks of 1 are the channels for which acquisition cycles are extended and bit mask of 0 are the channels for which acquisition cycles are not extended.</dd></dl>
<dl compact><dt><b>Note:</b></dt><dd>None </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="dc282160cb9b1394d0ea2aadf5d90f72"></a><!-- doxytag: member="xadcps.c::XAdcPs_GetSeqAvgEnables" ref="dc282160cb9b1394d0ea2aadf5d90f72" args="(XAdcPs *InstancePtr)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">u32 XAdcPs_GetSeqAvgEnables           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="struct_x_adc_ps.html">XAdcPs</a> *&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>InstancePtr</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
This function returns the channels for which the averaging has been enabled in the ADC Channel Averaging Enables Sequencer Registers.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the <a class="el" href="struct_x_adc_ps.html">XAdcPs</a> instance.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>The status of averaging (enabled/disabled) for all the channels. Use XADCPS_SEQ_CH__* defined in <a class="el" href="xadcps__hw_8h.html">xadcps_hw.h</a> to interpret the Channel numbers. Bit masks of 1 are the channels for which averaging is enabled and bit mask of 0 are the channels for averaging is disabled</dd></dl>
<dl compact><dt><b>Note:</b></dt><dd>None </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="4dfa7cb131a2662e79d0339cda300c5f"></a><!-- doxytag: member="xadcps.c::XAdcPs_GetSeqChEnables" ref="4dfa7cb131a2662e79d0339cda300c5f" args="(XAdcPs *InstancePtr)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">u32 XAdcPs_GetSeqChEnables           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="struct_x_adc_ps.html">XAdcPs</a> *&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>InstancePtr</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
This function gets the channel enable bits status from the ADC Channel Selection Sequencer Registers.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the <a class="el" href="struct_x_adc_ps.html">XAdcPs</a> instance.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>Gets the channel enable bits. Use XADCPS_SEQ_CH__* defined in <a class="el" href="xadcps__hw_8h.html">xadcps_hw.h</a> to interpret the Channel numbers. Bit masks of 1 are the channels that are enabled and bit mask of 0 are the channels that are disabled.<p>
None</dd></dl>
<dl compact><dt><b>Note:</b></dt><dd>None </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="4dfaa1fa8fafabaa9f9d8e9ef0b42a12"></a><!-- doxytag: member="xadcps.c::XAdcPs_GetSeqInputMode" ref="4dfaa1fa8fafabaa9f9d8e9ef0b42a12" args="(XAdcPs *InstancePtr)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">u32 XAdcPs_GetSeqInputMode           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="struct_x_adc_ps.html">XAdcPs</a> *&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>InstancePtr</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
This function gets the Analog input mode for all the channels from the ADC Channel Analog-Input Mode Sequencer Registers.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the <a class="el" href="struct_x_adc_ps.html">XAdcPs</a> instance.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>The input mode for all the channels. Use XADCPS_SEQ_CH_* defined in <a class="el" href="xadcps__hw_8h.html">xadcps_hw.h</a> to interpret the Channel numbers. Bit masks of 1 are the channels for which input mode is differential and bit mask of 0 are the channels for which input mode is unipolar.</dd></dl>
<dl compact><dt><b>Note:</b></dt><dd>None. </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="dff9343d1535fd4dd5054e9ff9723071"></a><!-- doxytag: member="xadcps.c::XAdcPs_GetSequencerMode" ref="dff9343d1535fd4dd5054e9ff9723071" args="(XAdcPs *InstancePtr)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">u8 XAdcPs_GetSequencerMode           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="struct_x_adc_ps.html">XAdcPs</a> *&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>InstancePtr</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
This function gets the channel sequencer mode from the Configuration Register 1.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the <a class="el" href="struct_x_adc_ps.html">XAdcPs</a> instance.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>The channel sequencer mode :<ul>
<li>XADCPS_SEQ_MODE_SAFE : Default safe mode</li><li>XADCPS_SEQ_MODE_ONEPASS : One pass through sequence</li><li>XADCPS_SEQ_MODE_CONTINPASS : Continuous channel sequencing</li><li>XADCPS_SEQ_MODE_SINGCHAN : Single channel/Sequencer off</li><li>XADCPS_SEQ_MODE_SIMUL_SAMPLING : Simulataneous sampling mode</li><li>XADCPS_SEQ_MODE_INDEPENDENT : Independent mode</li></ul>
</dd></dl>
<dl compact><dt><b>Note:</b></dt><dd>None. </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="5db30b0df7d870e32224c7e79b7b34c6"></a><!-- doxytag: member="xadcps.c::XAdcPs_ReadInternalReg" ref="5db30b0df7d870e32224c7e79b7b34c6" args="(XAdcPs *InstancePtr, u32 RegOffset)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">u32 XAdcPs_ReadInternalReg           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="struct_x_adc_ps.html">XAdcPs</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>u32&nbsp;</td>
          <td class="mdname" nowrap> <em>RegOffset</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
This function is used for reading from the XADC Registers using the Data FIFO.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the <a class="el" href="struct_x_adc_ps.html">XAdcPs</a> instance. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>RegOffset</em>&nbsp;</td><td>is the offset of the XADC register to be read.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>Data read from the FIFO</dd></dl>
<dl compact><dt><b>Note:</b></dt><dd>None. </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="62c9d1e95b7bacb188900fd60364d2e9"></a><!-- doxytag: member="xadcps.c::XAdcPs_Reset" ref="62c9d1e95b7bacb188900fd60364d2e9" args="(XAdcPs *InstancePtr)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">void XAdcPs_Reset           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="struct_x_adc_ps.html">XAdcPs</a> *&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>InstancePtr</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
This function resets the XADC Hard Macro in the device.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the Xxadc instance.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>None.</dd></dl>
<dl compact><dt><b>Note:</b></dt><dd>None. </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="84e41567de12a07d011c4c0892f73cd3"></a><!-- doxytag: member="xadcps.c::XAdcPs_SetAdcClkDivisor" ref="84e41567de12a07d011c4c0892f73cd3" args="(XAdcPs *InstancePtr, u8 Divisor)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">void XAdcPs_SetAdcClkDivisor           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="struct_x_adc_ps.html">XAdcPs</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>u8&nbsp;</td>
          <td class="mdname" nowrap> <em>Divisor</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
The function sets the frequency of the ADCCLK by configuring the DCLK to ADCCLK ratio in the Configuration Register #2<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the <a class="el" href="struct_x_adc_ps.html">XAdcPs</a> instance. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>Divisor</em>&nbsp;</td><td>is clock divisor used to derive ADCCLK from DCLK. Valid values of the divisor are<ul>
<li>0 to 255. Values 0, 1, 2 are all mapped to 2. Refer to the device specification for more details</li></ul>
</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>None.</dd></dl>
<dl compact><dt><b>Note:</b></dt><dd>- The ADCCLK is an internal clock used by the ADC and is synchronized to the DCLK clock. The ADCCLK is equal to DCLK divided by the user selection in the Configuration Register 2.<ul>
<li>There is no Assert on the minimum value of the Divisor. </li></ul>
</dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="464cf138a9f9ffdebef7b9058bf310ee"></a><!-- doxytag: member="xadcps.c::XAdcPs_SetAlarmEnables" ref="464cf138a9f9ffdebef7b9058bf310ee" args="(XAdcPs *InstancePtr, u16 AlmEnableMask)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">void XAdcPs_SetAlarmEnables           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="struct_x_adc_ps.html">XAdcPs</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>u16&nbsp;</td>
          <td class="mdname" nowrap> <em>AlmEnableMask</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
This function enables the alarm outputs for the specified alarms in the Configuration Register 1.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the <a class="el" href="struct_x_adc_ps.html">XAdcPs</a> instance. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>AlmEnableMask</em>&nbsp;</td><td>is the bit-mask of the alarm outputs to be enabled in the Configuration Register 1. Bit positions of 1 will be enabled. Bit positions of 0 will be disabled. This mask is formed by OR'ing XADCPS_CFR1_ALM_*_MASK and XADCPS_CFR1_OT_MASK masks defined in <a class="el" href="xadcps__hw_8h.html">xadcps_hw.h</a>.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>None.</dd></dl>
<dl compact><dt><b>Note:</b></dt><dd>The implementation of the alarm enables in the Configuration register 1 is such that the alarms for bit positions of 1 will be disabled and alarms for bit positions of 0 will be enabled. The alarm outputs specified by the AlmEnableMask are negated before writing to the Configuration Register 1. </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="8446d59497c00607c474742f6872f31e"></a><!-- doxytag: member="xadcps.c::XAdcPs_SetAlarmThreshold" ref="8446d59497c00607c474742f6872f31e" args="(XAdcPs *InstancePtr, u8 AlarmThrReg, u16 Value)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">void XAdcPs_SetAlarmThreshold           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="struct_x_adc_ps.html">XAdcPs</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>u8&nbsp;</td>
          <td class="mdname" nowrap> <em>AlarmThrReg</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>u16&nbsp;</td>
          <td class="mdname" nowrap> <em>Value</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
This functions sets the contents of the given Alarm Threshold Register.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the <a class="el" href="struct_x_adc_ps.html">XAdcPs</a> instance. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>AlarmThrReg</em>&nbsp;</td><td>is the index of an Alarm Threshold Register to be set. Use XADCPS_ATR_* constants defined in xadcps.h to specify the index. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>Value</em>&nbsp;</td><td>is the 16-bit threshold value to write into the register.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>None.</dd></dl>
<dl compact><dt><b>Note:</b></dt><dd>Use XAdcPs_SetOverTemp() to set the Over Temperature upper threshold value. </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="9a12f9e2efed38a375540bb80d7fdd36"></a><!-- doxytag: member="xadcps.c::XAdcPs_SetAvg" ref="9a12f9e2efed38a375540bb80d7fdd36" args="(XAdcPs *InstancePtr, u8 Average)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">void XAdcPs_SetAvg           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="struct_x_adc_ps.html">XAdcPs</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>u8&nbsp;</td>
          <td class="mdname" nowrap> <em>Average</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
This function sets the number of samples of averaging that is to be done for all the channels in both the single channel mode and sequence mode of operations.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the <a class="el" href="struct_x_adc_ps.html">XAdcPs</a> instance. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>Average</em>&nbsp;</td><td>is the number of samples of averaging programmed to the Configuration Register 0. Use the XADCPS_AVG_* definitions defined in xadcps.h file :<ul>
<li>XADCPS_AVG_0_SAMPLES for no averaging</li><li>XADCPS_AVG_16_SAMPLES for 16 samples of averaging</li><li>XADCPS_AVG_64_SAMPLES for 64 samples of averaging</li><li>XADCPS_AVG_256_SAMPLES for 256 samples of averaging</li></ul>
</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>None.</dd></dl>
<dl compact><dt><b>Note:</b></dt><dd>None. </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="89b6af9a72a63d8492ac07eb6e707f6d"></a><!-- doxytag: member="xadcps.c::XAdcPs_SetCalibEnables" ref="89b6af9a72a63d8492ac07eb6e707f6d" args="(XAdcPs *InstancePtr, u16 Calibration)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">void XAdcPs_SetCalibEnables           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="struct_x_adc_ps.html">XAdcPs</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>u16&nbsp;</td>
          <td class="mdname" nowrap> <em>Calibration</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
This function enables the specified calibration in the Configuration Register 1 :<p>
<ul>
<li>XADCPS_CFR1_CAL_ADC_OFFSET_MASK : Calibration 0 -ADC offset correction</li><li>XADCPS_CFR1_CAL_ADC_GAIN_OFFSET_MASK : Calibration 1 -ADC gain and offset correction</li><li>XADCPS_CFR1_CAL_PS_OFFSET_MASK : Calibration 2 -Power Supply sensor offset correction</li><li>XADCPS_CFR1_CAL_PS_GAIN_OFFSET_MASK : Calibration 3 -Power Supply sensor gain and offset correction</li><li>XADCPS_CFR1_CAL_DISABLE_MASK : No Calibration</li></ul>
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the <a class="el" href="struct_x_adc_ps.html">XAdcPs</a> instance. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>Calibration</em>&nbsp;</td><td>is the Calibration to be applied. Use XADCPS_CFR1_CAL*_* bits defined in <a class="el" href="xadcps__hw_8h.html">xadcps_hw.h</a>. Multiple calibrations can be enabled at a time by oring the XADCPS_CFR1_CAL_ADC_* and XADCPS_CFR1_CAL_PS_* bits. Calibration can be disabled by specifying XADCPS_CFR1_CAL_DISABLE_MASK;</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>None.</dd></dl>
<dl compact><dt><b>Note:</b></dt><dd>None. </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="364d653e98319ec31d422bc6eb34d5db"></a><!-- doxytag: member="xadcps.c::XAdcPs_SetConfigRegister" ref="364d653e98319ec31d422bc6eb34d5db" args="(XAdcPs *InstancePtr, u32 Data)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">void XAdcPs_SetConfigRegister           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="struct_x_adc_ps.html">XAdcPs</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>u32&nbsp;</td>
          <td class="mdname" nowrap> <em>Data</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
The functions sets the contents of the Config Register.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the <a class="el" href="struct_x_adc_ps.html">XAdcPs</a> instance. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>Data</em>&nbsp;</td><td>is the 32 bit data to be written to the Register.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>None.</dd></dl>
<dl compact><dt><b>Note:</b></dt><dd>None. </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="88cd4f42d4ae6fbd13a9a20992c47549"></a><!-- doxytag: member="xadcps.c::XAdcPs_SetMiscCtrlRegister" ref="88cd4f42d4ae6fbd13a9a20992c47549" args="(XAdcPs *InstancePtr, u32 Data)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">void XAdcPs_SetMiscCtrlRegister           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="struct_x_adc_ps.html">XAdcPs</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>u32&nbsp;</td>
          <td class="mdname" nowrap> <em>Data</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
The functions sets the contents of the Miscellaneous Control register.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the <a class="el" href="struct_x_adc_ps.html">XAdcPs</a> instance. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>Data</em>&nbsp;</td><td>is the 32 bit data to be written to the Register.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>None.</dd></dl>
<dl compact><dt><b>Note:</b></dt><dd>None. </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="1d913d7cb0af6268eb81e2adfbe0f605"></a><!-- doxytag: member="xadcps.c::XAdcPs_SetMuxMode" ref="1d913d7cb0af6268eb81e2adfbe0f605" args="(XAdcPs *InstancePtr, int MuxMode, u8 Channel)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">void XAdcPs_SetMuxMode           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="struct_x_adc_ps.html">XAdcPs</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap> <em>MuxMode</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>u8&nbsp;</td>
          <td class="mdname" nowrap> <em>Channel</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
This function sets the External Mux mode.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the <a class="el" href="struct_x_adc_ps.html">XAdcPs</a> instance. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>MuxMode</em>&nbsp;</td><td>specifies whether External Mux is used<ul>
<li>FALSE specifies NO external MUX</li><li>TRUE specifies External Mux is used </li></ul>
</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>Channel</em>&nbsp;</td><td>specifies the channel to be used for the external Mux. Please read the Device Spec for which channels are valid for which mode.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>None.</dd></dl>
<dl compact><dt><b>Note:</b></dt><dd>There is no Assert in this function for checking the channel number if the external Mux is used. The user should provide a valid channel number. </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="81888ec31e0f6069c9186c3f29c19712"></a><!-- doxytag: member="xadcps.c::XAdcPs_SetPowerdownMode" ref="81888ec31e0f6069c9186c3f29c19712" args="(XAdcPs *InstancePtr, u32 Mode)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">void XAdcPs_SetPowerdownMode           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="struct_x_adc_ps.html">XAdcPs</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>u32&nbsp;</td>
          <td class="mdname" nowrap> <em>Mode</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
This function sets the Power Down mode.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the <a class="el" href="struct_x_adc_ps.html">XAdcPs</a> instance. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>Mode</em>&nbsp;</td><td>specifies the Power Down Mode<ul>
<li>XADCPS_PD_MODE_NONE specifies NO Power Down (Both ADC A and ADC B are enabled)</li><li>XADCPS_PD_MODE_ADCB specfies the Power Down of ADC B</li><li>XADCPS_PD_MODE_XADC specifies the Power Down of both ADC A and ADC B.</li></ul>
</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>None.</dd></dl>
<dl compact><dt><b>Note:</b></dt><dd>None. </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="d9478172811e6610b5c14677e2cab026"></a><!-- doxytag: member="xadcps.c::XAdcPs_SetSeqAcqTime" ref="d9478172811e6610b5c14677e2cab026" args="(XAdcPs *InstancePtr, u32 AcqCyclesChMask)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">int XAdcPs_SetSeqAcqTime           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="struct_x_adc_ps.html">XAdcPs</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>u32&nbsp;</td>
          <td class="mdname" nowrap> <em>AcqCyclesChMask</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
This function sets the number of Acquisition cycles in the ADC Channel Acquisition Time Sequencer Registers. The sequencer must be disabled before writing to these regsiters.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the <a class="el" href="struct_x_adc_ps.html">XAdcPs</a> instance. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>AcqCyclesChMask</em>&nbsp;</td><td>is the bit mask of all the channels for which the number of acquisition cycles is to be extended. Use XADCPS_SEQ_CH__* defined in <a class="el" href="xadcps__hw_8h.html">xadcps_hw.h</a> to specify the Channel numbers. Acquisition cycles will be extended to 10 ADCCLK cycles for bit masks of 1 and will be the default 4 ADCCLK cycles for bit masks of 0. The AcqCyclesChMask is a 32 bit mask that is written to the two 16 bit ADC Channel Acquisition Time Sequencer Registers.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd><ul>
<li>XST_SUCCESS if the given values were written successfully to the Channel Sequencer Registers.</li><li>XST_FAILURE if the channel sequencer is enabled.</li></ul>
</dd></dl>
<dl compact><dt><b>Note:</b></dt><dd>None. </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="c475391c24bfeeb4be68e770b13cb55a"></a><!-- doxytag: member="xadcps.c::XAdcPs_SetSeqAvgEnables" ref="c475391c24bfeeb4be68e770b13cb55a" args="(XAdcPs *InstancePtr, u32 AvgEnableChMask)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">int XAdcPs_SetSeqAvgEnables           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="struct_x_adc_ps.html">XAdcPs</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>u32&nbsp;</td>
          <td class="mdname" nowrap> <em>AvgEnableChMask</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
This function enables the averaging for the specified channels in the ADC Channel Averaging Enable Sequencer Registers. The sequencer must be disabled before writing to these regsiters.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the <a class="el" href="struct_x_adc_ps.html">XAdcPs</a> instance. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>AvgEnableChMask</em>&nbsp;</td><td>is the bit mask of all the channels for which averaging is to be enabled. Use XADCPS_SEQ_CH__* defined in <a class="el" href="xadcps__hw_8h.html">xadcps_hw.h</a> to specify the Channel numbers. Averaging will be enabled for bit masks of 1 and disabled for bit mask of 0. The AvgEnableChMask is a 32 bit mask that is written to the two 16 bit ADC Channel Averaging Enable Sequencer Registers.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd><ul>
<li>XST_SUCCESS if the given values were written successfully to the ADC Channel Averaging Enables Sequencer Registers.</li><li>XST_FAILURE if the channel sequencer is enabled.</li></ul>
</dd></dl>
<dl compact><dt><b>Note:</b></dt><dd>None </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="4f9f4c3d8d0b08ae1f4bef4ef443ccc6"></a><!-- doxytag: member="xadcps.c::XAdcPs_SetSeqChEnables" ref="4f9f4c3d8d0b08ae1f4bef4ef443ccc6" args="(XAdcPs *InstancePtr, u32 ChEnableMask)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">int XAdcPs_SetSeqChEnables           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="struct_x_adc_ps.html">XAdcPs</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>u32&nbsp;</td>
          <td class="mdname" nowrap> <em>ChEnableMask</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
This function enables the specified channels in the ADC Channel Selection Sequencer Registers. The sequencer must be disabled before writing to these regsiters.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the <a class="el" href="struct_x_adc_ps.html">XAdcPs</a> instance. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>ChEnableMask</em>&nbsp;</td><td>is the bit mask of all the channels to be enabled. Use XADCPS_SEQ_CH__* defined in <a class="el" href="xadcps__hw_8h.html">xadcps_hw.h</a> to specify the Channel numbers. Bit masks of 1 will be enabled and bit mask of 0 will be disabled. The ChEnableMask is a 32 bit mask that is written to the two 16 bit ADC Channel Selection Sequencer Registers.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd><ul>
<li>XST_SUCCESS if the given values were written successfully to the ADC Channel Selection Sequencer Registers.</li><li>XST_FAILURE if the channel sequencer is enabled.</li></ul>
</dd></dl>
<dl compact><dt><b>Note:</b></dt><dd>None </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="414937b31ae3cc20852834b100d91eb4"></a><!-- doxytag: member="xadcps.c::XAdcPs_SetSeqInputMode" ref="414937b31ae3cc20852834b100d91eb4" args="(XAdcPs *InstancePtr, u32 InputModeChMask)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">int XAdcPs_SetSeqInputMode           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="struct_x_adc_ps.html">XAdcPs</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>u32&nbsp;</td>
          <td class="mdname" nowrap> <em>InputModeChMask</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
This function sets the Analog input mode for the specified channels in the ADC Channel Analog-Input Mode Sequencer Registers. The sequencer must be disabled before writing to these regsiters.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the <a class="el" href="struct_x_adc_ps.html">XAdcPs</a> instance. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>InputModeChMask</em>&nbsp;</td><td>is the bit mask of all the channels for which the input mode is differential mode. Use XADCPS_SEQ_CH__* defined in <a class="el" href="xadcps__hw_8h.html">xadcps_hw.h</a> to specify the channel numbers. Differential input mode will be set for bit masks of 1 and unipolar input mode for bit masks of 0. The InputModeChMask is a 32 bit mask that is written to the two 16 bit ADC Channel Analog-Input Mode Sequencer Registers.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd><ul>
<li>XST_SUCCESS if the given values were written successfully to the ADC Channel Analog-Input Mode Sequencer Registers.</li><li>XST_FAILURE if the channel sequencer is enabled.</li></ul>
</dd></dl>
<dl compact><dt><b>Note:</b></dt><dd>None </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="c7d91697f463582f5f48d5aff623b778"></a><!-- doxytag: member="xadcps.c::XAdcPs_SetSequencerEvent" ref="c7d91697f463582f5f48d5aff623b778" args="(XAdcPs *InstancePtr, int IsEventMode)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">void XAdcPs_SetSequencerEvent           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="struct_x_adc_ps.html">XAdcPs</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap> <em>IsEventMode</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
The function enables the Event mode or Continuous mode in the sequencer mode.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the <a class="el" href="struct_x_adc_ps.html">XAdcPs</a> instance. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>IsEventMode</em>&nbsp;</td><td>is a boolean parameter that specifies continuous sampling (specify FALSE) or event driven sampling mode (specify TRUE) for the given channel.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>None.</dd></dl>
<dl compact><dt><b>Note:</b></dt><dd>None. </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="26624a7ccd6a695882f3f199dd883a26"></a><!-- doxytag: member="xadcps.c::XAdcPs_SetSequencerMode" ref="26624a7ccd6a695882f3f199dd883a26" args="(XAdcPs *InstancePtr, u8 SequencerMode)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">void XAdcPs_SetSequencerMode           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="struct_x_adc_ps.html">XAdcPs</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>u8&nbsp;</td>
          <td class="mdname" nowrap> <em>SequencerMode</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
This function sets the specified Channel Sequencer Mode in the Configuration Register 1 :<ul>
<li>Default safe mode (XADCPS_SEQ_MODE_SAFE)</li><li>One pass through sequence (XADCPS_SEQ_MODE_ONEPASS)</li><li>Continuous channel sequencing (XADCPS_SEQ_MODE_CONTINPASS)</li><li>Single Channel/Sequencer off (XADCPS_SEQ_MODE_SINGCHAN)</li><li>Simulataneous sampling mode (XADCPS_SEQ_MODE_SIMUL_SAMPLING)</li><li>Independent mode (XADCPS_SEQ_MODE_INDEPENDENT)</li></ul>
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the <a class="el" href="struct_x_adc_ps.html">XAdcPs</a> instance. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>SequencerMode</em>&nbsp;</td><td>is the sequencer mode to be set. Use XADCPS_SEQ_MODE_* bits defined in xadcps.h. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>None.</dd></dl>
<dl compact><dt><b>Note:</b></dt><dd>Only one of the modes can be enabled at a time. Please read the Spec of the XADC for further information about the sequencer modes. </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="a5e8bd1e9e69cee5bfb5a5b1daa98533"></a><!-- doxytag: member="xadcps.c::XAdcPs_SetSingleChParams" ref="a5e8bd1e9e69cee5bfb5a5b1daa98533" args="(XAdcPs *InstancePtr, u8 Channel, int IncreaseAcqCycles, int IsEventMode, int IsDifferentialMode)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">int XAdcPs_SetSingleChParams           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="struct_x_adc_ps.html">XAdcPs</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>u8&nbsp;</td>
          <td class="mdname" nowrap> <em>Channel</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap> <em>IncreaseAcqCycles</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap> <em>IsEventMode</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap> <em>IsDifferentialMode</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
The function sets the given parameters in the Configuration Register 0 in the single channel mode.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the <a class="el" href="struct_x_adc_ps.html">XAdcPs</a> instance. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>Channel</em>&nbsp;</td><td>is the channel number for the singel channel mode. The valid channels are 0 to 5, 8, and 16 to 31. If the external Mux is used then this specifies the channel oonnected to the external Mux. Please read the Device Spec to know which channels are valid. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>IncreaseAcqCycles</em>&nbsp;</td><td>is a boolean parameter which specifies whether the Acquisition time for the external channels has to be increased to 10 ADCCLK cycles (specify TRUE) or remain at the default 4 ADCCLK cycles (specify FALSE). This parameter is only valid for the external channels. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>IsDifferentialMode</em>&nbsp;</td><td>is a boolean parameter which specifies unipolar(specify FALSE) or differential mode (specify TRUE) for the analog inputs. The input mode is only valid for the external channels.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd><ul>
<li>XST_SUCCESS if the given values were written successfully to the Configuration Register 0.</li><li>XST_FAILURE if the channel sequencer is enabled or the input parameters are not valid for the selected channel.</li></ul>
</dd></dl>
<dl compact><dt><b>Note:</b></dt><dd><ul>
<li>The number of samples for the averaging for all the channels is set by using the function XAdcPs_SetAvg.</li><li>The calibration of the device is done by doing a ADC conversion on the calibration channel(channel 8). The input parameters IncreaseAcqCycles, IsDifferentialMode and IsEventMode are not valid for this channel </li></ul>
</dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="2d733f758ddbec9f6adb3f7a5c92c932"></a><!-- doxytag: member="xadcps.c::XAdcPs_WriteInternalReg" ref="2d733f758ddbec9f6adb3f7a5c92c932" args="(XAdcPs *InstancePtr, u32 RegOffset, u32 Data)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">void XAdcPs_WriteInternalReg           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="struct_x_adc_ps.html">XAdcPs</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>u32&nbsp;</td>
          <td class="mdname" nowrap> <em>RegOffset</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>u32&nbsp;</td>
          <td class="mdname" nowrap> <em>Data</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
This function is used for writing to XADC Registers using the command FIFO.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the <a class="el" href="struct_x_adc_ps.html">XAdcPs</a> instance. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>RegOffset</em>&nbsp;</td><td>is the offset of the XADC register to be written. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>Data</em>&nbsp;</td><td>is the data to be written.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>None.</dd></dl>
<dl compact><dt><b>Note:</b></dt><dd>None. </dd></dl>
    </td>
  </tr>
</table>
Copyright @ 1995-2014 Xilinx, Inc. All rights reserved. 
